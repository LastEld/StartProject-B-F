import pytest
from sqlalchemy.orm import Session
from app.crud.task import (
    create_task,
    get_task,
    get_all_tasks,
    update_task,
    soft_delete_task,
    restore_task
)
from app.crud.project import create_project as create_project_for_task # To create parent project
from app.models.user import User as UserModel
from app.models.project import Project as ProjectModel
from app.models.task import Task as TaskModel
from app.core.exceptions import TaskValidationError, TaskNotFound
from datetime import date, timedelta, datetime, timezone
from unittest.mock import patch
import uuid # For unique names/titles

# Using the same mocked schema as for project tests for consistency
MOCKED_CUSTOM_FIELDS_SCHEMA = {
    "valid_text_field": {
        "type": "str",
        "validator": lambda v: isinstance(v, str) and len(v) < 100,
    },
    "valid_number_field": {
        "type": "int",
        "validator": lambda v: isinstance(v, int) and v > 0,
    },
}

@pytest.fixture
def sample_project(db: Session, test_user: UserModel) -> ProjectModel:
    """Creates a sample project for tasks to belong to."""
    project_data = {
        "name": f"Task's Parent Project {uuid.uuid4().hex[:6]}",
        "author_id": test_user.id,
    }
    with patch('app.crud.project.CUSTOM_FIELDS_SCHEMA', {}): # No custom fields for this simple project
        project = create_project_for_task(db, project_data)
    return project

@pytest.fixture
def basic_task_data(sample_project: ProjectModel):
    return {
        "title": f"Test Task {uuid.uuid4().hex[:6]}",
        "description": "A test task description",
        "project_id": sample_project.id,
        "task_status": "todo",
        "priority": 3,
        "deadline": date.today() + timedelta(days=15),
        "tags": ["testing", "crud"],
        "assignees": [{"user_id": 1, "name": "Test User"}] # Example assignee
    }

# --- Tests for create_task ---
def test_create_task_success(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        task = create_task(db, task_data)

    assert task is not None
    assert task.title == task_data["title"]
    assert task.project_id == sample_project.id
    assert task.description == task_data["description"]
    assert task.task_status == "todo"
    assert task.priority == 3
    assert task.is_deleted is False

    db_task = db.query(TaskModel).filter(TaskModel.id == task.id).first()
    assert db_task is not None
    assert db_task.title == task_data["title"]

def test_create_task_minimal_fields(db: Session, sample_project: ProjectModel):
    task_title = f"Minimal Task {uuid.uuid4().hex[:6]}"
    task_data = {
        "title": task_title,
        "project_id": sample_project.id
    }
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        task = create_task(db, task_data)

    assert task is not None
    assert task.title == task_title
    assert task.project_id == sample_project.id
    assert task.description == "" # Default
    assert task.task_status == "todo" # Default
    assert task.priority == 3 # Default

def test_create_task_missing_title(db: Session, sample_project: ProjectModel):
    task_data = {"project_id": sample_project.id}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Title is required."):
            create_task(db, task_data)

def test_create_task_empty_title(db: Session, sample_project: ProjectModel):
    task_data = {"title": "  ", "project_id": sample_project.id}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Title is required."):
            create_task(db, task_data)

def test_create_task_missing_project_id(db: Session):
    task_data = {"title": "Task without project"}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Project ID is required."):
            create_task(db, task_data) # Also raises KeyError if project_id not in data for unique check

def test_create_task_duplicate_title_in_project(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data1 = basic_task_data.copy()
    # Ensure title is fixed for this test, not dynamically generated by fixture for uniqueness
    fixed_title = "Duplicate Title Task"
    task_data1["title"] = fixed_title

    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        create_task(db, task_data1)

        task_data2 = task_data1.copy() # Same title, same project
        with pytest.raises(TaskValidationError, match="Task title must be unique within a project."):
            create_task(db, task_data2)

def test_create_task_past_deadline(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["deadline"] = date.today() - timedelta(days=1)
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Deadline cannot be in the past."):
            create_task(db, task_data)

def test_create_task_invalid_deadline_format(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["deadline"] = "not-a-date"
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Invalid deadline date format. Use YYYY-MM-DD."):
            create_task(db, task_data)

def test_create_task_priority_out_of_range(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["priority"] = 0 # Too low
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Priority must be an integer between 1 and 5."):
            create_task(db, task_data)

    task_data["priority"] = 6 # Too high
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Priority must be an integer between 1 and 5."):
            create_task(db, task_data)

def test_create_task_invalid_tags_type(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["tags"] = "not-a-list"
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Tags must be a list of strings."):
            create_task(db, task_data)

    task_data["tags"] = [1, 2, 3] # List, but not of strings
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Tags must be a list of strings."):
            create_task(db, task_data)

def test_create_task_invalid_assignees_type(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["assignees"] = "not-a-list"
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Assignees must be a list."):
            create_task(db, task_data)

def test_create_task_valid_custom_fields(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["custom_fields"] = {"valid_text_field": "text", "valid_number_field": 10}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        task = create_task(db, task_data)
    assert task.custom_fields["valid_text_field"] == "text"
    assert task.custom_fields["valid_number_field"] == 10

def test_create_task_invalid_custom_field_value(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["custom_fields"] = {"valid_number_field": -5} # Validator expects > 0
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Invalid value for 'valid_number_field': -5"):
            create_task(db, task_data)

# --- Tests for get_task ---
def test_get_task_success(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        created_task = create_task(db, task_data)
        fetched_task = get_task(db, created_task.id)

    assert fetched_task is not None
    assert fetched_task.id == created_task.id
    assert fetched_task.title == created_task.title

def test_get_task_not_found(db: Session):
    with pytest.raises(TaskNotFound, match="Task 99999 not found"):
        get_task(db, 99999) # Assuming 99999 does not exist

def test_get_task_soft_deleted_default_not_found(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["title"] = f"Soft Del Task {uuid.uuid4().hex[:6]}"
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        created_task = create_task(db, task_data)
        # Manually soft-delete for testing get_task directly
        created_task.is_deleted = True
        created_task.deleted_at = datetime.now(timezone.utc)
        db.commit()
        db.refresh(created_task)

    with pytest.raises(TaskNotFound, match=f"Task {created_task.id} not found \\(or is deleted\\)"):
        get_task(db, created_task.id) # Default include_deleted=False

def test_get_task_soft_deleted_included(db: Session, sample_project: ProjectModel, basic_task_data: dict):
    task_data = basic_task_data.copy()
    task_data["title"] = f"Soft Del Incl Task {uuid.uuid4().hex[:6]}"
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        created_task = create_task(db, task_data)
        # Manually soft-delete
        created_task.is_deleted = True
        created_task.deleted_at = datetime.now(timezone.utc)
        db.commit()
        db.refresh(created_task)

        fetched_task = get_task(db, created_task.id, include_deleted=True)

    assert fetched_task is not None
    assert fetched_task.id == created_task.id
    assert fetched_task.is_deleted is True

# --- Tests for get_all_tasks ---
@pytest.fixture
def task_set(db: Session, sample_project: ProjectModel, test_user: UserModel):
    # Ensure CUSTOM_FIELDS_SCHEMA is patched for task creation within this fixture
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        tasks_data = [
            {"title": "Task Alpha (high prio, today)", "project_id": sample_project.id, "priority": 1, "deadline": date.today(), "tags": ["urgent", "fix"], "task_status": "todo", "is_favorite": True, "assignees": [{"user_id": test_user.id, "name": "Test User"}]},
            {"title": "Task Beta (low prio, future)", "project_id": sample_project.id, "priority": 5, "deadline": date.today() + timedelta(days=10), "tags": ["feature"], "task_status": "inprogress", "reviewed": True},
            {"title": "Task Gamma (archived, past)", "project_id": sample_project.id, "priority": 3, "deadline": date.today() + timedelta(days=1), "tags": ["old"], "task_status": "done", "is_deleted": True, "deleted_at": datetime.now(timezone.utc)}, # Valid deadline for creation
            {"title": "Task Delta (no deadline, searchkey)", "project_id": sample_project.id, "priority": 2, "description": "Contains a unique searchkey for testing.", "tags": ["planning"], "task_status": "backlog"},
            {"title": "Task Epsilon (custom field val)", "project_id": sample_project.id, "priority": 4, "custom_fields": {"valid_text_field": "findme"}, "task_status": "todo"},
        ]
        created_tasks = []
        for data_item in tasks_data:
            data_item["title"] = f"{data_item['title']} {uuid.uuid4().hex[:4]}" # Ensure unique titles
            is_del = data_item.pop("is_deleted", False)
            del_at = data_item.pop("deleted_at", None)

            task = create_task(db, data_item)
            if is_del:
                task.is_deleted = True
                task.deleted_at = del_at
                task.task_status = data_item.get("task_status", "archived")
                db.commit()
                db.refresh(task)
            created_tasks.append(task)
    return created_tasks

def test_get_all_tasks_default_for_project(db: Session, sample_project: ProjectModel, task_set):
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id})
    # Should return 3 non-deleted tasks: Alpha, Beta, Delta, Epsilon
    assert len(tasks) == 4
    for task in tasks:
        assert task.project_id == sample_project.id
        assert task.is_deleted is False

def test_get_all_tasks_show_archived(db: Session, sample_project: ProjectModel, task_set):
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "show_archived": True})
    # Should return all 5 tasks for the project
    assert len(tasks) == 5

def test_get_all_tasks_filter_status(db: Session, sample_project: ProjectModel, task_set):
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "task_status": "inprogress"})
    assert len(tasks) == 1
    assert "Task Beta" in tasks[0].title

def test_get_all_tasks_filter_priority(db: Session, sample_project: ProjectModel, task_set):
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "priority": 1})
    assert len(tasks) == 1
    assert "Task Alpha" in tasks[0].title

def test_get_all_tasks_filter_tag(db: Session, sample_project: ProjectModel, task_set):
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "tag": "urgent"})
    assert len(tasks) == 1
    assert "Task Alpha" in tasks[0].title

def test_get_all_tasks_filter_search(db: Session, sample_project: ProjectModel, task_set):
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "search": "searchkey"})
    assert len(tasks) == 1
    assert "Task Delta" in tasks[0].title

def test_get_all_tasks_filter_deadline_after(db: Session, sample_project: ProjectModel, task_set):
    # Task Beta is +10 days, Task Alpha is today
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "deadline_after": date.today() + timedelta(days=5)})
    assert len(tasks) == 1
    assert "Task Beta" in tasks[0].title

def test_get_all_tasks_filter_custom_field(db: Session, sample_project: ProjectModel, task_set):
    # Need to ensure the custom_fields[key].astext == str(value) logic in crud works.
    # This requires the specific custom field key and value from task_set.
    # Task Epsilon has {"valid_text_field": "findme"}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA): # Ensure schema is patched for get_all_tasks if it uses it
        tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "custom_fields": {"valid_text_field": "findme"}})
    assert len(tasks) == 1
    assert "Task Epsilon" in tasks[0].title

def test_get_all_tasks_filter_assignee_id(db: Session, sample_project: ProjectModel, test_user: UserModel, task_set):
    # Task Alpha is assigned to test_user (id=1 assumed by fixture)
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id, "assignee_id": test_user.id})
    assert len(tasks) >= 1 # Can be more if other tests assigned this user
    found = False
    for task in tasks:
        if "Task Alpha" in task.title:
            found = True
            break
    assert found, "Task Alpha assigned to test_user not found"

def test_get_all_tasks_sort_priority(db: Session, sample_project: ProjectModel, task_set):
    tasks = get_all_tasks(db, filters={"project_id": sample_project.id}, sort_by="priority")
    # Expects ascending for priority: Alpha (1), Delta (2), Beta (5), Epsilon (4)
    # Default non-deleted: Alpha (1), Delta (2), Epsilon (4), Beta (5)
    assert len(tasks) == 4
    assert "Task Alpha" in tasks[0].title # Prio 1
    assert "Task Delta" in tasks[1].title # Prio 2
    assert "Task Epsilon" in tasks[2].title # Prio 4
    assert "Task Beta" in tasks[3].title # Prio 5

# --- Tests for update_task ---
@pytest.fixture
def task_for_update(db: Session, basic_task_data: dict):
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        task = create_task(db, basic_task_data.copy())
    return task

def test_update_task_success(db: Session, task_for_update: TaskModel):
    original_updated_at = task_for_update.updated_at
    import time; time.sleep(0.001) # Ensure timestamp difference

    update_data = {
        "title": "Updated Task Title",
        "description": "Updated task description.",
        "task_status": "inprogress",
        "priority": 1,
        "deadline": date.today() + timedelta(days=5),
        "tags": ["updated"],
        "assignees": [{"user_id": 2, "name": "Another User"}],
        "custom_fields": {"valid_text_field": "updated_text"},
        "is_favorite": True,
        "reviewed": True
    }
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        updated_task = update_task(db, task_for_update.id, update_data)

    assert updated_task.title == "Updated Task Title"
    assert updated_task.description == "Updated task description."
    assert updated_task.task_status == "inprogress"
    assert updated_task.priority == 1
    assert updated_task.deadline == date.today() + timedelta(days=5)
    assert "updated" in updated_task.tags
    assert updated_task.assignees[0]["user_id"] == 2
    assert updated_task.custom_fields["valid_text_field"] == "updated_text"
    assert updated_task.is_favorite is True
    assert updated_task.reviewed is True
    assert updated_task.updated_at > original_updated_at

def test_update_task_partial(db: Session, task_for_update: TaskModel):
    original_title = task_for_update.title
    update_data = {"task_status": "done"}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        updated_task = update_task(db, task_for_update.id, update_data)

    assert updated_task.task_status == "done"
    assert updated_task.title == original_title # Other fields unchanged

def test_update_task_not_found(db: Session):
    with pytest.raises(TaskNotFound):
        update_task(db, 88888, {"title": "Ghost Task"})

def test_update_task_empty_title(db: Session, task_for_update: TaskModel):
    update_data = {"title": ""}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Task title is required."):
            update_task(db, task_for_update.id, update_data)

def test_update_task_past_deadline_not_done(db: Session, task_for_update: TaskModel):
    update_data = {"deadline": date.today() - timedelta(days=1), "task_status": "todo"}
    # Ensure task is not 'done' before attempting to set past deadline
    task_for_update.task_status = "todo"
    db.commit()

    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Deadline cannot be set to a past date."):
            update_task(db, task_for_update.id, update_data)

def test_update_task_past_deadline_status_done(db: Session, task_for_update: TaskModel):
    # Setting a past deadline IS allowed if the task status is already 'done' or being set to 'done'
    update_data = {"deadline": date.today() - timedelta(days=1), "task_status": "done"}
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        updated_task = update_task(db, task_for_update.id, update_data)
    assert updated_task.deadline == date.today() - timedelta(days=1)
    assert updated_task.task_status == "done"

def test_update_task_invalid_custom_field_update(db: Session, task_for_update: TaskModel):
    update_data = {"custom_fields": {"valid_number_field": -50}} # Invalid value
    with patch('app.crud.task.CUSTOM_FIELDS_SCHEMA', MOCKED_CUSTOM_FIELDS_SCHEMA):
        with pytest.raises(TaskValidationError, match="Invalid value for 'valid_number_field': -50"):
            update_task(db, task_for_update.id, update_data)

# --- Tests for soft_delete_task ---
def test_soft_delete_task_success(db: Session, task_for_update: TaskModel): # Reusing task_for_update fixture
    task_id = task_for_update.id

    deleted_task_obj = soft_delete_task(db, task_id)
    assert deleted_task_obj is not None
    assert deleted_task_obj.is_deleted is True
    assert deleted_task_obj.deleted_at is not None
    assert deleted_task_obj.task_status == "archived"

    with pytest.raises(TaskNotFound):
        get_task(db, task_id) # Should not find by default

    found_deleted_task = get_task(db, task_id, include_deleted=True)
    assert found_deleted_task is not None
    assert found_deleted_task.is_deleted is True

def test_soft_delete_task_not_found(db: Session):
    with pytest.raises(TaskNotFound):
        soft_delete_task(db, 99999)

def test_soft_delete_task_already_deleted(db: Session, task_for_update: TaskModel):
    soft_delete_task(db, task_for_update.id) # First delete
    with pytest.raises(TaskValidationError, match="Task already archived."):
        soft_delete_task(db, task_for_update.id) # Second delete

# --- Tests for restore_task ---
def test_restore_task_success(db: Session, task_for_update: TaskModel):
    task_id = task_for_update.id
    soft_delete_task(db, task_id) # Delete it first

    # Ensure it's deleted
    deleted_task_check = get_task(db, task_id, include_deleted=True)
    assert deleted_task_check.is_deleted is True

    restored_task = restore_task(db, task_id)
    assert restored_task is not None
    assert restored_task.is_deleted is False
    assert restored_task.deleted_at is None
    assert restored_task.task_status == "todo" # Assuming restore sets to 'todo'

    found_restored_task = get_task(db, task_id) # Should find by default now
    assert found_restored_task is not None
    assert found_restored_task.is_deleted is False

def test_restore_task_not_found(db: Session):
    with pytest.raises(TaskNotFound):
        restore_task(db, 88888)

def test_restore_task_not_deleted(db: Session, task_for_update: TaskModel):
    task_id = task_for_update.id
    # Ensure task is not deleted
    active_task = get_task(db, task_id)
    assert active_task.is_deleted is False

    with pytest.raises(TaskValidationError, match=f"Task with id={task_id} is not archived/deleted."):
        restore_task(db, task_id)

# TODO: Add tests for get_ai_context and summarize_task (lower priority)
